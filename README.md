Instant download **Solution Manual for C++ How to Program 10th by Deitel** by click link bellow:  
[https://testbankbell.com/product/solution-manual-for-c-how-to-program-10th-by-deitel/](https://testbankbell.com/product/solution-manual-for-c-how-to-program-10th-by-deitel/)  
**Instant download Solution Manual for C++ How to Program 10th by Deitel pdf docx epub after payment.**
-------------------------------------------------------------------------------------------------------


![](https://testbankbell.com/wp-content/uploads/2023/05/51vjUIGh2IL._SX380_BO1204203200_-1.jpg)
**Product details:**
--------------------


* ISBN-10 ‏ : ‎ 9780134448237
* * ISBN-13 ‏ : ‎ 978-0134448237
  * * Author: Paul Deitel
   
  * The best-selling C++ How to Program is accessible to readers with little or no programming experience, yet comprehensive enough for the professional programmer. The Deitels’ signature live-code approach presents the concepts in the context of full working programs followed by sample executions. The early objects approach gets readers thinking about objects immediately–allowing them to more thoroughly master the concepts. Emphasis is placed on achieving program clarity and building well-engineered software. Interesting, entertaining, and challenging exercises encourage students to make a difference and use computers and the Internet to work on problems. To keep readers up-to-date with leading-edge computing technologies, the Tenth Edition conforms to the C++11 standard and the new C++14 standard.
  * **Table of contents:**
  * ----------------------
 
* **1 Introduction to Computers and C++ 1**
* 1.1 Introduction
* 1.2 Computers and the Internet in Industry and Research
* 1.3 Hardware and Software
* 1.3.1 Moore’s Law
* 1.3.2 Computer Organization
* 1.4 Data Hierarchy
* 1.5 Machine Languages, Assembly Languages and High-Level Languages
* 1.6 C and C++
* 1.7 Programming Languages
* 1.8 Introduction to Object Technology
* 1.9 Typical C++ Development Environment
* 1.10 Test-Driving a C++ Application
* 1.10.1 Compiling and Running an Application in Visual Studio 2015 for Windows
* 1.10.2 Compiling and Running Using GNU C++ on Linux
* 1.10.3 Compiling and Running with Xcode on Mac OS X
* 1.11 Operating Systems
* 1.11.1 Windows–A Proprietary Operating System
* 1.11.2 Linux–An Open-Source Operating System
* 1.11.3 Apple’s OS X; Apple’s iOS for iPhone®, iPad® and iPod Touch® Devices
* 1.11.4 Google’s Android
* 1.12 The Internet and the World Wide Web
* 1.13 Some Key Software Development Terminology
* 1.14 C++11 and C++14: The Latest C++ Versions
* 1.15 Boost C++ Libraries
* 1.16 Keeping Up to Date with Information Technologies
* **2 Introduction to C++ Programming, Input/Output and Operators**
* 2.1 Introduction
* 2.2 First Program in C++: Printing a Line of Text
* 2.3 Modifying Our First C++ Program
* 2.4 Another C++ Program: Adding Integers
* 2.5 Memory Concepts
* 2.6 Arithmetic
* 2.7 Decision Making: Equality and Relational Operators
* 2.8 Wrap-Up
* **3 Introduction to Classes, Objects, Member Functions and Strings**
* 3.1 Introduction
* 3.2 Test-Driving an Account Object
* 3.2.1 Instantiating an Object
* 3.2.2 Headers and Source-Code Files
* 3.2.3 Calling Class Account’s getName Member Function
* 3.2.4 Inputting a string with getline
* 3.2.5 Calling Class Account’s setName Member Function
* 3.3 Account Class with a Data Member and Set and Get Member Functions
* 3.3.1 Account Class Definition
* 3.3.2 Keyword class and the Class Body
* 3.3.3 Data Member name of Type string
* 3.3.4 setName Member Function
* 3.3.5 getName Member Function
* 3.3.6 Access Specifiers private and public
* 3.3.7 Account UML Class Diagram
* 3.4 Account Class: Initializing Objects with Constructors
* 3.4.1 Defining an Account Constructor for Custom Object Initialization
* 3.4.2 Initializing Account Objects When They’re Created
* 3.4.3 Account UML Class Diagram with a Constructor
* 3.5 Software Engineering with Set and Get Member Functions
* 3.6 Account Class with a Balance; Data Validation
* 3.6.1 Data Member balance
* 3.6.2 Two-Parameter Constructor with Validation
* 3.6.3 deposit Member Function with Validation
* 3.6.4 getBalance Member Function
* 3.6.5 Manipulating Account Objects with Balances
* 3.6.6 Account UML Class Diagram with a Balance and Member Functions deposit and getBalance
* 3.7 Wrap-Up
* **4 Algorithm Development and Control Statements: Part 1**
* 4.1 Introduction
* 4.2 Algorithms
* 4.3 Pseudocode
* 4.4 Control Structures
* 4.4.1 Sequence Structure
* 4.4.2 Selection Statements
* 4.4.3 Iteration Statements
* 4.4.4 Summary of Control Statements
* 4.5 if Single-Selection Statement
* 4.6 if…else Double-Selection Statement
* 4.6.1 Nested if…else Statements
* 4.6.2 Dangling-else Problem
* 4.6.3 Blocks
* 4.6.4 Conditional Operator (?:)
* 4.7 Student Class: Nested if…else Statements
* 4.8 while Iteration Statement
* 4.9 Formulating Algorithms: Counter-Controlled Iteration
* 4.9.1 Pseudocode Algorithm with Counter-Controlled Iteration
* 4.9.2 Implementing Counter-Controlled Iteration
* 4.9.3 Notes on Integer Division and Truncation
* 4.9.4 Arithmetic Overflow
* 4.9.5 Input Validation
* 4.10 Formulating Algorithms: Sentinel-Controlled Iteration
* 4.10.1 Top-Down, Stepwise Refinement: The Top and First Refinement
* 4.10.2 Proceeding to the Second Refinement
* 4.10.3 Implementing Sentinel-Controlled Iteration
* 4.10.4 Converting Between Fundamental Types Explicitly and Implicitly
* 4.10.5 Formatting Floating-Point Numbers
* 4.10.6 Unsigned Integers and User Input
* 4.11 Formulating Algorithms: Nested Control Statements
* 4.11.1 Problem Statement
* 4.11.2 Top-Down, Stepwise Refinement: Pseudocode Representation of the Top
* 4.11.3 Top-Down, Stepwise Refinement: First Refinement
* 4.11.4 Top-Down, Stepwise Refinement: Second Refinement
* 4.11.5 Complete Second Refinement of the Pseudocode
* 4.11.6 Program That Implements the Pseudocode Algorithm
* 4.11.7 Preventing Narrowing Conversions with List Initialization
* 4.12 Compound Assignment Operators
* 4.13 Increment and Decrement Operators
* 4.14 Fundamental Types Are Not Portable
* 4.15Wrap-Up
* **5 Control Statements: Part 2; Logical Operators**
* 5.1 Introduction
* 5.2 Essentials of Counter-Controlled Iteration
* 5.3 for Iteration Statement
* 5.4 Examples Using the for Statement
* 5.5 Application: Summing Even Integers
* 5.6 Application: Compound-Interest Calculations
* 5.7 Case Study: Integer-Based Monetary Calculations with Class DollarAmount
* 5.7.1 Demonstrating Class DollarAmount
* 5.7.2 Class DollarAmount
* 5.8 do…while Iteration Statement
* 5.9 switch Multiple-Selection Statement
* 5.10 break and continue Statements
* 5.10.1 break Statement
* 5.10.2 continue Statement
* 5.11 Logical Operators
* 5.11.1 Logical AND (&&) Operator
* 5.11.2 Logical OR (||) Operator
* 5.11.3 Short-Circuit Evaluation
* 5.11.4 Logical Negation (!) Operator
* 5.11.5 Logical Operators Example
* 5.12 Confusing the Equality (==) and Assignment (=) Operators
* 5.13 Structured-Programming Summary
* 5.14Wrap-Up
* **6 Functions and an Introduction to Recursion**
* 6.1 Introduction
* 6.2 Program Components in C++
* 6.3 Math Library Functions
* 6.4 Function Prototypes
* 6.5 Function-Prototype and Argument-Coercion Notes
* 6.5.1 Function Signatures and Function Prototypes
* 6.5.2 Argument Coercion
* 6.5.3 Argument-Promotion Rules and Implicit Conversions
* 6.6 C++ Standard Library Headers
* 6.7 Case Study: Random-Number Generation
* 6.7.1 Rolling a Six-Sided Die
* 6.7.2 Rolling a Six-Sided Die 60,000,000 Times
* 6.7.3 Randomizing the Random-Number Generator with srand
* 6.7.4 Seeding the Random-Number Generator with the Current Time
* 6.7.5 Scaling and Shifting Random Numbers
* 6.8 Case Study: Game of Chance; Introducing Scoped enums
* 6.9 C++11 Random Numbers
* 6.10 Scope Rules
* 6.11 Function-Call Stack and Activation Records
* 6.12 Inline Functions
* 6.13 References and Reference Parameters
* 6.14 Default Arguments
* 6.15 Unary Scope Resolution Operator
* 6.16 Function Overloading
* 6.17 Function Templates
* 6.18Recursion
* 6.19 Example Using Recursion: Fibonacci Series
* 6.20 Recursion vs. Iteration
* 6.21Wrap-Up
* **7 Class Templates array and vector; Catching Exceptions**
* 7.1 Introduction
* 7.2 arrays
* 7.3 Declaring arrays
* 7.4 Examples Using arrays
* 7.4.1 Declaring an array and Using a Loop to Initialize the array’s Elements
* 7.4.2 Initializing an array in a Declaration with an Initializer List
* 7.4.3 Specifying an array’s Size with a Constant Variable and Setting array Elements with Calculations
* 7.4.4 Summing the Elements of an array
* 7.4.5 Using a Bar Chart to Display array Data Graphically
* 7.4.6 Using the Elements of an array as Counters
* 7.4.7 Using arrays to Summarize Survey Results
* 7.4.8 Static Local arrays and Automatic Local arrays
* 7.5 Range-Based for Statement
* 7.6 Case Study: Class GradeBook Using an array to Store Grades
* 7.7 Sorting and Searching arrays
* 7.7.1 Sorting
* 7.7.2 Searching
* 7.7.3 Demonstrating Functions sort and binary\_search
* 7.8 Multidimensional arrays
* 7.9 Case Study: Class GradeBook Using a Two-Dimensional array
* 7.10 Introduction to C++ Standard Library Class Template vector
* 7.11Wrap-Up

* **8 Pointers**
* 8.1 Introduction
* 8.2 Pointer Variable Declarations and Initialization
* 8.2.1 Declaring Pointers
* 8.2.2 Initializing Pointers
* 8.2.3 Null Pointers Prior to C++11
* 8.3 Pointer Operators
* 8.3.1 Address (&) Operator
* 8.3.2 Indirection (\*) Operator
* 8.3.3 Using the Address (&) and Indirection (\*) Operators
* 8.4 Pass-by-Reference with Pointers
* 8.5 Built-In Arrays
* 8.5.1 Declaring and Accessing a Built-In Array
* 8.5.2 Initializing Built-In Arrays
* 8.5.3 Passing Built-In Arrays to Functions
* 8.5.4 Declaring Built-In Array Parameters
* 8.5.5 C++11: Standard Library Functions begin and end
* 8.5.6 Built-In Array Limitations
* 8.5.7 Built-In Arrays Sometimes Are Required
* 8.6 Using const with Pointers
* 8.6.1 Nonconstant Pointer to Nonconstant Data
* 8.6.2 Nonconstant Pointer to Constant Data
* 8.6.3 Constant Pointer to Nonconstant Data
* 8.6.4 Constant Pointer to Constant Data
* 8.7 sizeof Operator
* 8.8 Pointer Expressions and Pointer Arithmetic
* 8.8.1 Adding Integers to and Subtracting Integers from Pointers
* 8.8.2 Subtracting Pointers
* 8.8.3 Pointer Assignment
* 8.8.4 Cannot Dereference a void\*
* 8.8.5 Comparing Pointers
* 8.9 Relationship Between Pointers and Built-In Arrays
* 8.9.1 Pointer/Offset Notation
* 8.9.2 Pointer/Offset Notation with the Built-In Array’s Name as the Pointer
* 8.9.3 Pointer/Subscript Notation
* 8.9.4 Demonstrating the Relationship Between Pointers and Built-In Arrays
* 8.10 Pointer-Based Strings (Optional)
* 8.11 Note About Smart Pointers
* 8.12Wrap-Up
* **9 Classes: A Deeper Look**
* 9.1 Introduction
* 9.2 Time Class Case Study: Separating Interface from Implementation
* 9.2.1 Interface of a Class
* 9.2.2 Separating the Interface from the Implementation
* 9.2.3 Time Class Definition
* 9.2.4 Time Class Member Functions
* 9.2.5 Scope Resolution Operator (::)
* 9.2.6 Including the Class Header in the Source-Code File
* 9.2.7 Time Class Member Function setTime and Throwing Exceptions
* 9.2.8 Time Class Member Function toUniversalString and String Stream Processing
* 9.2.9 Time Class Member Function toStandardString
* 9.2.10 Implicitly Inlining Member Functions
* 9.2.11 Member Functions vs. Global Functions
* 9.2.12 Using Class Time
* 9.2.13 Object Size
* 9.3 Compilation and Linking Process
* 9.4 Class Scope and Accessing Class Members
* 9.5 Access Functions and Utility Functions
* 9.6 Time Class Case Study: Constructors with Default Arguments
* 9.6.1 Constructors with Default Arguments
* 9.6.2 Overloaded Constructors and C++11 Delegating Constructors
* 9.7 Destructors
* 9.8 When Constructors and Destructors Are Called
* 9.8.1 Constructors and Destructors for Objects in Global Scope
* 9.8.2 Constructors and Destructors for Non-static Local Objects
* 9.8.3 Constructors and Destructors for static Local Objects
* 9.8.4 Demonstrating When Constructors and Destructors Are Called
* 9.9 Time Class Case Study: A Subtle Trap–Returning a Reference or a Pointer to a private Data Member
* 9.10 Default Memberwise Assignment
* 9.11 const Objects and const Member Functions
* 9.12 Composition: Objects as Members of Classes
* 9.13 friend Functions and friend Classes
* 9.14 Using the this Pointer
* 9.14.1 Implicitly and Explicitly Using the this Pointer to Access an Object’s Data Members
* 9.14.2 Using the this Pointer to Enable Cascaded Function Calls
* 9.15 static Class Members
* 9.15.1 Motivating Classwide Data
* 9.15.2 Scope and Initialization of static Data Members
* 9.15.3 Accessing static Data Members
* 9.15.4 Demonstrating static Data Members
* 9.16Wrap-Up
* **10 Operator Overloading; Class string**
* 10.1 Introduction
* 10.2 Using the Overloaded Operators of Standard Library Class string
* 10.3 Fundamentals of Operator Overloading
* 10.3.1 Operator Overloading Is Not Automatic
* 10.3.2 Operators That You Do Not Have to Overload
* 10.3.3 Operators That Cannot Be Overloaded
* 10.3.4 Rules and Restrictions on Operator Overloading
* 10.4 Overloading Binary Operators
* 10.5 Overloading the Binary Stream Insertion and Stream Extraction Operators
* 10.6 Overloading Unary Operators
* 10.7 Overloading the Increment and Decrement Operators
* 10.8 Case Study: A Date Class
* 10.9 Dynamic Memory Management
* 10.10 Case Study: Array Class
* 10.10.1 Using the Array Class
* 10.10.2 Array Class Definition
* 10.11 Operators as Member vs. Non-Member Functions
* 10.12 Converting Between Types
* 10.13 explicit Constructors and Conversion Operators
* 10.14 Overloading the Function Call Operator ()
* 10.15 Wrap-Up
* **11 Object-Oriented Programming: Inheritance**
* 11.1 Introduction
* 11.2 Base Classes and Derived Classes
* 11.2.1 CommunityMember Class Hierarchy
* 11.2.2 Shape Class Hierarchy
* 11.3 Relationship between Base and Derived Classes
* 11.3.1 Creating and Using a CommissionEmployee Class
* 11.3.2 Creating a BasePlusCommissionEmployee Class Without Using Inheritance
* 11.3.3 Creating a CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy
* 11.3.4 CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy Using protected Data
* 11.3.5 CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy Using private Data
* 11.4 Constructors and Destructors in Derived Classes
* 11.5 public, protected and private Inheritance
* 11.6Wrap-Up
* **12 Object-Oriented Programming: Polymorphism**
* 12.1 Introduction
* 12.2 Introduction to Polymorphism: Polymorphic Video Game
* 12.3 Relationships Among Objects in an Inheritance Hierarchy
* 12.3.1 Invoking Base-Class Functions from Derived-Class Objects
* 12.3.2 Aiming Derived-Class Pointers at Base-Class Objects
* 12.3.3 Derived-Class Member-Function Calls via Base-Class Pointers
* 12.4 Virtual Functions and Virtual Destructors
* 12.4.1 Why virtual Functions Are Useful
* 12.4.2 Declaring virtual Functions
* 12.4.3 Invoking a virtual Function Through a Base-Class Pointer or Reference
* 12.4.4 Invoking a virtual Function Through an Object’s Name
* 12.4.5 virtual Functions in the CommissionEmployee Hierarchy
* 12.4.6 virtual Destructors
* 12.4.7 C++11: final Member Functions and Classes
* 12.5 Type Fields and switch Statements
* 12.6 Abstract Classes and Pure virtual Functions
* 12.6.1 Pure virtual Functions
* 12.6.2 Device Drivers: Polymorphism in Operating Systems
* 12.7 Case Study: Payroll System Using Polymorphism
* 12.7.1 Creating Abstract Base Class Employee
* 12.7.2 Creating Concrete Derived Class SalariedEmployee
* 12.7.3 Creating Concrete Derived Class CommissionEmployee
* 12.7.4 Creating Indirect Concrete Derived Class BasePlusCommissionEmployee
* 12.7.5 Demonstrating Polymorphic Processing
* 12.8 (Optional) Polymorphism, Virtual Functions and Dynamic Binding “Under the Hood”
* 12.9 Case Study: Payroll System Using Polymorphism and Runtime Type Information with Downcasting, dynamic\_cast, typeid and type\_info 567
* 12.10 Wrap-Up
* **13 Stream Input/Output: A Deeper Look**
* 13.1 Introduction
* 13.2 Streams
* 13.2.1 Classic Streams vs. Standard Streams
* 13.2.2 iostream Library Headers
* 13.2.3 Stream Input/Output Classes and Objects
* 13.3 Stream Output
* 13.3.1 Output of char\* Variables
* 13.3.2 Character Output Using Member Function put
* 13.4 Stream Input
* 13.4.1 get and getline Member Functions
* 13.4.2 istream Member Functions peek, putback and ignore
* 13.4.3 Type-Safe I/O
* 13.5 Unformatted I/O Using read, write and gcount
* 13.6 Stream Manipulators: A Deeper Look
* 13.6.1 Integral Stream Base: dec, oct, hex and setbase
* 13.6.2 Floating-Point Precision (precision, setprecision)
* 13.6.3 Field Width (width, setw)
* 13.6.4 User-Defined Output Stream Manipulators
* 13.7 Stream Format States and Stream Manipulators
* 13.7.1 Trailing Zeros and Decimal Points (showpoint)
* 13.7.2 Justification (left, right and internal)
* 13.7.3 Padding (fill, setfill)
* 13.7.4 Integral Stream Base (dec, oct, hex, showbase)
* 13.7.5 Floating-Point Numbers; Scientific and Fixed Notation (scientific, fixed)
* 13.7.6 Uppercase/Lowercase Control (uppercase)
* 13.7.7 Specifying Boolean Format (boolalpha)
* 13.7.8 Setting and Resetting the Format State via Member Function flags
* 13.8 Stream Error States
* 13.9 Tying an Output Stream to an Input Stream
* 13.10 Wrap-Up
* **14 File Processing**
* 14.1 Introduction
* 14.2 Files and Streams
* 14.3 Creating a Sequential File
* 14.3.1 Opening a File
* 14.3.2 Opening a File via the open Member Function
* 14.3.3 Testing Whether a File Was Opened Successfully
* 14.3.4 Overloaded bool Operator
* 14.3.5 Processing Data
* 14.3.6 Closing a File
* 14.3.7 Sample Execution
* 14.4 Reading Data from a Sequential File
* 14.4.1 Opening a File for Input
* 14.4.2 Reading from the File
* 14.4.3 File-Position Pointers
* 14.4.4 Case Study: Credit Inquiry Program
* 14.5 C++14: Reading and Writing Quoted Text
* 14.6 Updating Sequential Files
* 14.7 Random-Access Files
* 14.8 Creating a Random-Access File
* 14.8.1 Writing Bytes with ostream Member Function write
* 14.8.2 Converting Between Pointer Types with the reinterpret\_cast Operator
* 14.8.3 Credit-Processing Program
* 14.8.4 Opening a File for Output in Binary Mode
* 14.9 Writing Data Randomly to a Random-Access File
* 14.9.1 Opening a File for Input and Output in Binary Mode
* 14.9.2 Positioning the File-Position Pointer
* 14.10 Reading from a Random-Access File Sequentially
* 14.11 Case Study: A Transaction-Processing Program
* 14.12 Object Serialization
* 14.13 Wrap-Up
* **15 Standard Library Containers and Iterators**
* 15.1 Introduction
* 15.2 Introduction to Containers
* 15.3 Introduction to Iterators
* 15.4 Introduction to Algorithms
* 15.5 Sequence Containers
* 15.5.1 vector Sequence Container
* 15.5.2 list Sequence Container
* 15.5.3 deque Sequence Container
* 15.6 Associative Containers
* 15.6.1 multiset Associative Container
* 15.6.2 set Associative Container
* 15.6.3 multimap Associative Container
* 15.6.4 map Associative Container
* 15.7 Container Adapters
* 15.7.1 stack Adapter
* 15.7.2 queue Adapter
* 15.7.3 priority\_queue Adapter
* 15.8 Class bitset
* 15.9Wrap-Up
* **16 Standard Library Algorithms**
* 16.1 Introduction
* 16.2 Minimum Iterator Requirements
* 16.3 Lambda Expressions
* 16.3.1 Algorithm for\_each
* 16.3.2 Lambda with an Empty Introducer
* 16.3.3 Lambda with a Nonempty Introducer–Capturing Local Variables
* 16.3.4 Lambda Return Types
* 16.4Algorithms
* 16.4.1 fill, fill\_n, generate and generate\_n
* 16.4.2 equal, mismatch and lexicographical\_compare
* 16.4.3 remove, remove\_if, remove\_copy and remove\_copy\_if
* 16.4.4 replace, replace\_if, replace\_copy and replace\_copy\_if
* 16.4.5 Mathematical Algorithms
* 16.4.6 Basic Searching and Sorting Algorithms
* 16.4.7 swap, iter\_swap and swap\_ranges
* 16.4.8 copy\_backward, merge, unique and reverse
* 16.4.9 inplace\_merge, unique\_copy and reverse\_copy
* 16.4.10 Set Operations
* 16.4.11 lower\_bound, upper\_bound and equal\_range
* 16.4.12 min, max, minmax and minmax\_element
* 16.5 Function Objects
* 16.6 Standard Library Algorithm Summary
* 16.7Wrap-Up

* **17 Exception Handling: A Deeper Look**
* 17.1 Introduction
* 17.2 Exception-Handling Flow of Control; Defining an Exception Class
* 17.2.1 Defining an Exception Class to Represent the Type of Problem That Might Occur
* 17.2.2 Demonstrating Exception Handling
* 17.2.3 Enclosing Code in a try Block
* 17.2.4 Defining a catch Handler to Process a DivideByZeroException
* 17.2.5 Termination Model of Exception Handling
* 17.2.6 Flow of Program Control When the User Enters a Nonzero Denominator
* 17.2.7 Flow of Program Control When the User Enters a Denominator of Zero
* 17.3 Rethrowing an Exception
* 17.4 Stack Unwinding
* 17.5 When to Use Exception Handling
* 17.6 noexcept: Declaring Functions That Do Not Throw Exceptions
* 17.7 Constructors, Destructors and Exception Handling
* 17.7.1 Destructors Called Due to Exceptions
* 17.7.2 Initializing Local Objects to Acquire Resources
* 17.8 Processing new Failures
* 17.8.1 new Throwing bad\_alloc on Failure
* 17.8.2 new Returning nullptr on Failure
* 17.8.3 Handling new Failures Using Function set\_new\_handler
* 17.9 Class unique\_ptr and Dynamic Memory Allocation
* 17.9.1 unique\_ptr Ownership
* 17.9.2 unique\_ptr to a Built-In Array
* 17.10 Standard Library Exception Hierarchy
* 17.11 Wrap-Up

* **18 Introduction to Custom Templates**
* 18.1 Introduction
* 18.2 Class Templates
* 18.2.1 Creating Class Template Stack
* 18.2.2 Class Template Stack’s Data Representation
* 18.2.3 Class Template Stack’s Member Functions
* 18.2.4 Declaring a Class Template’s Member Functions Outside the Class Template Definition
* 18.2.5 Testing Class Template Stack
* 18.3 Function Template to Manipulate a Class-Template Specialization Object
* 18.4 Nontype Parameters
* 18.5 Default Arguments for Template Type Parameters
* 18.6 Overloading Function Templates
* 18.7 Wrap-Up

* **19 Custom Templatized Data Structures**
* 19.1 Introduction
* 19.1.1 Always Prefer the Standard Library’s Containers, Iterators and Algorithms, if Possible
* 19.1.2 Special Section: Building Your Own Compiler
* 19.2 Self-Referential Classes
* 19.3 Linked Lists
* 19.3.1 Testing Our Linked List Implementation
* 19.3.2 Class Template ListNode
* 19.3.3 Class Template List
* 19.3.4 Member Function insertAtFront
* 19.3.5 Member Function insertAtBack
* 19.3.6 Member Function removeFromFront
* 19.3.7 Member Function removeFromBack
* 19.3.8 Member Function print
* 19.3.9 Circular Linked Lists and Double Linked Lists
* 19.4 Stacks
* 19.4.1 Taking Advantage of the Relationship Between Stack and List
* 19.4.2 Implementing a Class Template Stack Class Based By Inheriting from List
* 19.4.3 Dependent Names in Class Templates
* 19.4.4 Testing the Stack Class Template
* 19.4.5 Implementing a Class Template Stack Class With Composition of a List Object
* 19.5 Queues
* 19.5.1 Applications of Queues
* 19.5.2 Implementing a Class Template Queue Class Based By Inheriting from List
* 19.5.3 Testing the Queue Class Template
* 19.6 Trees
* 19.6.1 Basic Terminology
* 19.6.2 Binary Search Trees
* 19.6.3 Testing the Tree Class Template
* 19.6.4 Class Template TreeNode
* 19.6.5 Class Template Tree
* 19.6.6 Tree Member Function insertNodeHelper
* 19.6.7 Tree Traversal Functions
* 19.6.8 Duplicate Elimination
* 19.6.9 Overview of the Binary Tree Exercises
* 19.7 Wrap-Up
* **20 Searching and Sorting**
* 20.1 Introduction
* 20.2 Searching Algorithms
* 20.2.1 Linear Search
* 20.2.2 Binary Search
* 20.3 Sorting Algorithms
* 20.3.1 Insertion Sort
* 20.3.2 Selection Sort
* 20.3.3 Merge Sort (A Recursive Implementation)
* 20.4Wrap-Up
* **21 Class string and String Stream Processing: A Deeper Look**
* 21.1 Introduction
* 21.2 string Assignment and Concatenation
* 21.3 Comparing strings
* 21.4 Substrings
* 21.5 Swapping strings
* 21.6 string Characteristics
* 21.7 Finding Substrings and Characters in a string
* 21.8 Replacing Characters in a string
* 21.9 Inserting Characters into a string
* 21.10 Conversion to Pointer-Based char\* Strings
* 21.11 Iterators
* 21.12 String Stream Processing
* 21.13 C++11 Numeric Conversion Functions
* 21.14 Wrap-Up

* **22 Bits, Characters, C Strings and structs**
* 22.1 Introduction
* 22.2 Structure Definitions
* 22.3 typedef and using
* 22.4 Example: Card Shuffling and Dealing Simulation
* 22.5 Bitwise Operators
* 22.6 Bit Fields
* 22.7 Character-Handling Library
* 22.8 C String-Manipulation Functions
* 22.9 C String-Conversion Functions
* 22.10 Search Functions of the C String-Handling Library
* 22.11 Memory Functions of the C String-Handling Library
* 22.12 Wrap-Up

* Chapters on the Web
* A Operator Precedence and Associativity
* B ASCII Character Set
* C Fundamental Types
* D Number Systems
* D.1 Introduction
* D.2 Abbreviating Binary Numbers as Octal and Hexadecimal Numbers
* D.3 Converting Octal and Hexadecimal Numbers to Binary Numbers
* D.4 Converting from Binary, Octal or Hexadecimal to Decimal
* D.5 Converting from Decimal to Binary, Octal or Hexadecimal
* D.6 Negative Binary Numbers: Two’s Complement Notation
* E Preprocessor
* E.1 Introduction
* E.2 #include Preprocessing Directive
* E.3 #define Preprocessing Directive: Symbolic Constants
* E.4 #define Preprocessing Directive: Macros
* E.5 Conditional Compilation
* E.6 #error and #pragma Preprocessing Directives
* E.7 Operators # and ##
* E.8 Predefined Symbolic Constants
* E.9 Assertions
* E.10 Wrap-Up
* Appendices on the Web
* Index

* Chapters 23—26 and Appendices F—J are PDF documents posted online at the book’s password-protected Companion Website, which is accessible from http://www.pearsonhighered.com/deitel.
* 23 Other Topics
* 24 C++11 and C++14: Additional Features
* 25 ATM Case Study, Part 1: Object-Oriented Design with the UM
* 26 ATM Case Study, Part 2: Implementing an Object-Oriented Design

* F C Legacy Code Topics
* G UML: Additional Diagram Types
* H Using the Visual Studio Debugger
* I Using the GNU C++ Debugger
* J Using the Xcode Debugger
* **People also search:**
* -----------------------

C++ How to Program 10th

C++ How to Program 10th pdf

C++ How to Program

how to continue program after exception in c++

c++ how to return to beginning of program


    Get more solution manual or test bank at: [https://testbankbell.com](https://testbankbell.com)
